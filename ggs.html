<!-- START OF FILE update_caps_no_demon.html -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>League Arena 3D - Stat Caps Update</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Beaufort+for+LOL:wght@700&family=Spiegel:wght@400;700&family=Roboto:wght@500;700&display=swap');

        /* --- GLOBAL & RESET --- */
        body { margin: 0; overflow: hidden; background-color: #05080a; font-family: 'Spiegel', 'Roboto', sans-serif; user-select: none; }
        #game-canvas { position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; z-index: 0; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
        .interactive-ui { pointer-events: auto; }

        /* --- LOADING SCREEN --- */
        #loading-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #010a13;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 200; pointer-events: auto;
            transition: opacity 0.5s;
        }
        .loader-ring {
            width: 60px; height: 60px; border: 4px solid #c8aa6e; border-top: 4px solid transparent;
            border-radius: 50%; animation: spin 1s linear infinite; margin-bottom: 20px;
        }
        .loading-text { color: #c8aa6e; font-family: 'Beaufort for LOL', serif; letter-spacing: 2px; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* --- AUGMENT UI --- */
        #augment-modal {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: none; flex-direction: column; justify-content: center; align-items: center;
            z-index: 100; pointer-events: auto;
            backdrop-filter: blur(5px);
        }
        .augment-header {
            font-family: 'Beaufort for LOL', serif; color: #f0e6d2; font-size: 42px; margin-bottom: 40px;
            text-shadow: 0 0 15px rgba(200, 170, 110, 0.6); text-transform: uppercase; letter-spacing: 2px;
        }
        .cards-container { display: flex; gap: 40px; justify-content: center; align-items: center; flex-wrap: wrap; max-width: 1200px; }
        
        .augment-card {
            width: 300px; height: 480px;
            background-color: #111318; 
            border: 2px solid #5c5b57;
            position: relative; display: flex; flex-direction: column; align-items: center;
            cursor: pointer; transition: transform 0.2s, box-shadow 0.2s; overflow: hidden; box-shadow: 0 0 10px #000;
            background-size: 100% 100%;
            background-position: center;
            background-repeat: no-repeat;
        }
        .augment-card:hover { transform: translateY(-15px) scale(1.02); z-index: 101; box-shadow: 0 20px 50px rgba(0,0,0,0.8); }
        
        .card-border-frame { position: absolute; top: 2px; left: 2px; right: 2px; bottom: 2px; border: 1px solid rgba(255,255,255,0.1); z-index: 1; pointer-events: none; }
        
        .aug-img-container { width: 100%; height: 160px; position: relative; z-index: 2; display: flex; justify-content: center; align-items: center; margin-top: 20px; background: radial-gradient(circle, rgba(255,255,255,0.05) 0%, transparent 70%); }
        .aug-icon-wrapper { width: 110px; height: 110px; position: relative; display: flex; justify-content: center; align-items: center; }
        .aug-icon { width: 90px; height: 90px; background-size: cover; background-position: center; background-repeat: no-repeat; z-index: 2; filter: drop-shadow(0 0 10px rgba(0,0,0,0.5)); border-radius: 8px; }
        .aug-tier-bg { position: absolute; width: 100%; height: 100%; background-image: url('https://raw.communitydragon.org/latest/plugins/rcp-be-lol-game-data/global/default/v1/champion-icons/-1.png'); background-size: contain; opacity: 0.2; z-index: 1; }
        
        .aug-content { flex: 1; width: 100%; padding: 10px 20px; box-sizing: border-box; display: flex; flex-direction: column; align-items: center; z-index: 2; text-align: center; }
        .aug-name { font-family: 'Beaufort for LOL', serif; color: #f0e6d2; font-size: 24px; margin-bottom: 5px; text-transform: uppercase; letter-spacing: 1px; text-shadow: 0 2px 4px rgba(0,0,0,0.8); line-height: 1; }
        .aug-type-badge { font-size: 11px; color: #c8aa6e; text-transform: uppercase; letter-spacing: 2px; background: rgba(200, 170, 110, 0.1); border: 1px solid #c8aa6e; padding: 2px 8px; margin-bottom: 20px; margin-top: 5px; }
        .aug-desc { color: #a09b8c; font-size: 13px; line-height: 1.4; font-weight: 400; }
        .aug-stat { color: #0acbe6; font-weight: bold; } 

        .card-silver { border-color: #798687; background-image: url('https://raw.githubusercontent.com/hiiragimikoto/arena-map-ui/refs/heads/main/sliver.png'); } 
        .card-silver .aug-name { color: #e1e1e1; }
        .card-gold { border-color: #c8aa6e; box-shadow: 0 0 15px rgba(200, 170, 110, 0.1); background-image: url('https://raw.githubusercontent.com/hiiragimikoto/arena-map-ui/refs/heads/main/gold.png'); } 
        .card-gold .aug-name { color: #f0e6d2; }
        .card-prismatic { border-color: #bd33a4; box-shadow: 0 0 15px rgba(189, 51, 164, 0.2); background-image: url('https://raw.githubusercontent.com/hiiragimikoto/arena-map-ui/refs/heads/main/rainbow.png'); } 
        .card-prismatic .aug-name { color: #ffabf1; text-shadow: 0 0 5px #bd33a4; }

        /* --- SCOREBOARD UI --- */
        #scoreboard {
            position: absolute; top: 23%; left: 50%; transform: translate(-50%, 0);
            display: none; flex-direction: row; gap: 6px; z-index: 150; pointer-events: none;
        }
        .sb-team-wrapper { display: flex; align-items: center; gap: 0; }
        .sb-team-logo { width: 60px; height: 60px; background-color: #0a0e14; border: 2px solid #0099cc; border-radius: 50%; z-index: 3; display: flex; justify-content: center; align-items: center; box-shadow: 0 0 15px rgba(0,0,0,0.8); position: relative; }
        .sb-team-logo.red { border-color: #cc3333; }
        .logo-img { width: 100%; height: 100%; border-radius: 50%; background-size: cover; background-position: center; background-repeat: no-repeat; }
        .sb-rows-container { display: flex; flex-direction: column; background: #010a13; border: 2px solid #5c4b1e; box-shadow: 0 0 20px rgba(0,0,0,0.8); min-width: 580px; position: relative; z-index: 1; }
        .sb-team-wrapper.left .sb-team-logo { margin-right: -30px; border-right: 2px solid #0099cc; }
        .sb-team-wrapper.left .sb-rows-container { padding-left: 35px; border-left: 2px solid #0099cc; border-top-left-radius: 35px; border-bottom-left-radius: 35px; }
        .sb-team-wrapper.right .sb-team-logo { margin-left: -30px; border-left: 2px solid #cc3333; order: 2; }
        .sb-team-wrapper.right .sb-rows-container { padding-right: 35px; border-right: 2px solid #cc3333; border-top-right-radius: 35px; border-bottom-right-radius: 35px; order: 1; flex-direction: column; }
        .sb-team-wrapper.right .sb-row { flex-direction: row-reverse; }
        .sb-team-wrapper.right .sb-portrait-group { margin-right: 0; margin-left: 15px; }
        .sb-team-wrapper.right .sb-spells-col { margin-right: 0; margin-left: 15px; }
        .sb-team-wrapper.right .sb-augments-row { margin-right: 0; margin-left: auto; justify-content: flex-end; }
        .sb-team-wrapper.right .sb-stats-col { text-align: left; }
        .sb-row { height: 70px; display: flex; align-items: center; padding: 0 15px; border-bottom: 1px solid rgba(255,255,255,0.05); position: relative; background: rgba(255,255,255,0.02); }
        .sb-row:last-child { border-bottom: none; }
        .sb-portrait-group { position: relative; width: 50px; height: 50px; margin-right: 15px; }
        .sb-portrait { width: 46px; height: 46px; border-radius: 50%; border: 2px solid #c8aa6e; background-size: cover; background-position: center; box-shadow: 0 0 10px rgba(0,0,0,0.8); }
        .sb-portrait.dead { filter: grayscale(100%); border-color: #555; }
        .sb-lvl { position: absolute; bottom: -2px; right: -2px; width: 18px; height: 18px; background: #1c1c1c; border: 1px solid #c8aa6e; color: #fff; font-size: 10px; font-weight: bold; display: flex; align-items: center; justify-content: center; border-radius: 50%; }
        .sb-spells-col { display: flex; flex-direction: column; gap: 4px; margin-right: 15px; }
        .sb-spell { width: 20px; height: 20px; border: 1px solid #444; background-size: cover; border-radius: 3px; background-color: #111; }
        .sb-augments-row { display: flex; gap: 4px; margin-right: auto; width: auto; flex-wrap: nowrap; align-items: center; }
        .sb-aug-icon { width: 32px; height: 32px; border: 1px solid #555; border-radius: 4px; background-color: #000; background-size: cover; flex-shrink: 0; }
        .sb-stats-col { text-align: right; min-width: 80px; }
        .sb-kda { font-family: 'Beaufort for LOL'; font-size: 18px; color: #f0e6d2; letter-spacing: 1px; }

        /* General UI */
        .hud-container { position: absolute; bottom: 0; left: 50%; transform: translateX(-50%); display: flex; align-items: flex-end; gap: 8px; padding-bottom: 15px; }
        #minimap { position: absolute; bottom: 15px; right: 15px; width: 160px; height: 160px; border: 2px solid #5c4b1e; background-color: #111; background-image: url('https://raw.githubusercontent.com/hiiragimikoto/arena-map-ui/refs/heads/main/map.png'); background-size: cover; background-position: center; z-index: 100; border-radius: 4px; box-shadow: 0 0 10px #000; }
        #mm-player, #mm-enemy { position: absolute; width: 8px; height: 8px; border-radius: 50%; border: 1px solid #fff; box-shadow: 0 0 2px #000; transform: translate(-50%, -50%); }
        #mm-player { background-color: #00ccff; }
        #mm-enemy { background-color: #ff3333; }

        .announcement-wrapper { position: absolute; top: 15%; left: 50%; transform: translateX(-50%); display: flex; align-items: center; gap: 15px; pointer-events: none; z-index: 20; display: none; }
        @keyframes slideDownFade { 0% { transform: translate(-50%, -50px); opacity: 0; } 100% { transform: translate(-50%, 0); opacity: 1; } }
        @keyframes fadeOut { 0% { opacity: 1; } 100% { opacity: 0; } }
        .ann-icon { width: 50px; height: 50px; border-radius: 50%; background-color: #111; border: 2px solid #c8aa6e; background-size: cover; background-position: center; background-image: url("https://ddragon.leagueoflegends.com/cdn/14.1.1/img/champion/Ezreal.png"); box-shadow: 0 0 10px rgba(0,0,0,0.8); }
        .ann-content { background: linear-gradient(to right, rgba(0,0,0,0), rgba(10,14,20,0.9) 20%, rgba(10,14,20,0.9) 80%, rgba(0,0,0,0)); padding: 10px 40px; text-align: center; }
        .ann-text { font-family: 'Beaufort for LOL', serif; font-size: 32px; color: #f0e6d2; text-transform: uppercase; text-shadow: 0 2px 4px #000; margin: 0; white-space: nowrap; }
        .ann-underline { width: 100%; height: 2px; background: linear-gradient(to right, transparent, #0088ff, transparent); margin-top: 5px; box-shadow: 0 0 5px #0088ff; }
        .ann-red .ann-text { color: #ffcccc; text-shadow: 0 0 5px #d12f2f; }
        .ann-red .ann-underline { background: linear-gradient(to right, transparent, #d12f2f, transparent); box-shadow: 0 0 5px #d12f2f; }

        .floating-bar { position: absolute; display: flex; align-items: center; pointer-events: none; transform: translate(-50%, -100%); z-index: 5; filter: drop-shadow(0 2px 4px rgba(0,0,0,0.8)); transition: opacity 0.2s; }
        .lvl-box { width: 24px; height: 24px; background: #111; border: 2px solid #555; color: white; font-size: 12px; font-weight: bold; display: flex; align-items: center; justify-content: center; z-index: 2; margin-right: -2px; }
        .bars-stack { display: flex; flex-direction: column; width: 100px; background: #000; border: 1px solid #333; padding: 1px; }
        .overhead-hp { height: 12px; width: 100%; background: #333; position: relative; margin-bottom: 1px; }
        .overhead-hp-fill { height: 100%; width: 100%; transition: width 0.1s linear; background-image: repeating-linear-gradient(90deg, transparent, transparent 19px, rgba(0,0,0,0.5) 20px); }
        .overhead-mana { height: 5px; width: 100%; background: #222; }
        .overhead-mana-fill { height: 100%; width: 100%; background: #1a4e9c; transition: width 0.1s linear; }
        .hp-green { background-color: #1a9c30; }
        .hp-red { background-color: #d12f2f; }
        .cast-bar-container { width: 100px; height: 8px; background: #111; border: 1px solid #000; margin-top: 2px; display: none; position: relative; }
        .cast-bar-fill { height: 100%; background: #d4c188; width: 0%; }
        .cast-text { position: absolute; top: -12px; left: 0; width: 100%; text-align: center; color: #fff; font-size: 9px; text-shadow: 1px 1px 0 #000; }

        /* --- STATS PANEL --- */
        .stats-panel {
            background-color: #010a13;
            border: 1px solid #5c4b1e;
            width: 80px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            padding: 4px;
            gap: 2px;
            margin-right: 5px;
            box-shadow: 0 0 10px #000;
        }
        .stat-row {
            display: flex;
            align-items: center;
            gap: 2px;
            font-size: 11px;
            font-weight: bold;
            color: #cdbe91;
            padding: 1px;
        }
        .stat-icon {
            width: 16px; height: 16px;
            background-size: cover;
        }
        /* Using League Wiki Icons */
        .icon-ad { background-image: url('https://wiki.leagueoflegends.com/en-us/images/thumb/Attack_damage_icon.png/20px-Attack_damage_icon.png'); }
        .icon-ap { background-image: url('https://wiki.leagueoflegends.com/en-us/images/thumb/Ability_power_icon.png/20px-Ability_power_icon.png'); }
        .icon-arm { background-image: url('https://wiki.leagueoflegends.com/en-us/images/thumb/Armor_icon.png/20px-Armor_icon.png'); }
        .icon-mr { background-image: url('https://wiki.leagueoflegends.com/en-us/images/thumb/Magic_resistance_icon.png/20px-Magic_resistance_icon.png'); }
        .icon-as { background-image: url('https://wiki.leagueoflegends.com/en-us/images/thumb/Attack_speed_icon.png/20px-Attack_speed_icon.png'); }
        .icon-ah { background-image: url('https://wiki.leagueoflegends.com/en-us/images/thumb/Cooldown_icon.png/15px-Cooldown_icon.png?50d14'); }
        .icon-crit { background-image: url('https://wiki.leagueoflegends.com/en-us/images/thumb/Critical_strike_chance_icon.png/20px-Critical_strike_chance_icon.png'); }
        .icon-ms { background-image: url('https://wiki.leagueoflegends.com/en-us/images/thumb/Movement_speed_icon.png/20px-Movement_speed_icon.png'); }

        .portrait-container { position: relative; z-index: 2; }
        .portrait-circle { width: 90px; height: 90px; background-color: #202124; border: 3px solid #c8aa6e; border-radius: 50%; background-image: url("https://ddragon.leagueoflegends.com/cdn/14.1.1/img/champion/Ezreal.png"); background-size: cover; background-position: center; background-repeat: no-repeat; box-shadow: 0 0 15px rgba(0,0,0,0.8); position: relative; overflow: hidden; }
        .portrait-circle.dead-filter { filter: grayscale(100%); border-color: #555; }
        .death-timer-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); display: flex; justify-content: center; align-items: center; color: #fff; font-size: 36px; font-weight: bold; z-index: 10; }
        .level-badge { position: absolute; bottom: -5px; right: -5px; background: #202124; border: 2px solid #c8aa6e; color: #fff; width: 28px; height: 28px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 13px; font-weight: bold; box-shadow: 0 2px 4px rgba(0,0,0,0.5); z-index: 11; }
        .center-panel { background: linear-gradient(to top, #080d11, #13171a); border: 2px solid #463714; border-top: 3px solid #c8aa6e; padding: 10px; display: flex; flex-direction: column; gap: 6px; box-shadow: 0 -5px 20px rgba(0,0,0,0.8); border-radius: 4px; }
        .skills-row { display: flex; gap: 6px; justify-content: center; }
        .skill-box { width: 42px; height: 42px; background: #222; border: 1px solid #5c5c5c; position: relative; cursor: pointer; transition: all 0.1s; background-size: cover; background-position: center; }
        .skill-box:hover { border-color: #c8aa6e; }
        .skill-box.cd-active { filter: grayscale(100%); pointer-events: none; border-color: #333; }
        .skill-box.disabled { filter: grayscale(100%); opacity: 0.4; cursor: not-allowed; border-color: #222; }
        .cd-timer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; color: white; font-weight: bold; font-size: 18px; text-shadow: 0 0 3px black; }
        .inventory-panel { background: #06080a; border: 2px solid #463714; border-top: 2px solid #5c4b1e; padding: 5px; display: flex; flex-direction: column; gap: 2px; box-shadow: 0 -5px 20px rgba(0,0,0,0.8); border-radius: 4px; width: max-content; height: auto; position: relative; }
        .inv-row { display: flex; gap: 2px; }
        .inv-slot { width: 32px; height: 32px; background: #111; border: 1px solid #333; background-size: cover; background-position: center; }
        .gold-display { color: #d4c188; font-size: 14px; font-weight: bold; text-align: center; margin-top: 4px; text-shadow: 1px 1px 0 #000; letter-spacing: 1px; display: flex; align-items: center; justify-content: center; gap: 4px; }
        .gold-icon { width: 12px; height: 12px; background: gold; border-radius: 50%; border: 1px solid #fff; }
        
        .item-green { background: linear-gradient(135deg, #1a4d1a, #2e8b57); border: 1px solid #4caf50; }
        .item-sword { background: linear-gradient(45deg, #555, #ccc); border: 1px solid #888; position: relative; }
        .item-sword::after { content: ''; position: absolute; top: 10%; left: 45%; width: 10%; height: 80%; background: #fff; transform: rotate(45deg); }
        .item-pick { background: linear-gradient(to bottom, #444, #222); border: 1px solid #666; position: relative; }
        .item-pick::before { content: ''; position: absolute; top: 20%; left: 10%; width: 80%; height: 20%; background: #aaa; transform: rotate(-10deg); }

        #btn-q { background-image: url('https://ddragon.leagueoflegends.com/cdn/15.24.1/img/spell/EzrealQ.png'); }
        #btn-w { background-image: url('https://ddragon.leagueoflegends.com/cdn/15.24.1/img/spell/EzrealW.png'); }
        #btn-e { background-image: url('https://ddragon.leagueoflegends.com/cdn/15.24.1/img/spell/EzrealE.png'); }
        #btn-r { background-image: url('https://ddragon.leagueoflegends.com/cdn/15.24.1/img/spell/EzrealR.png'); }
        #btn-d { background-image: url('https://ddragon.leagueoflegends.com/cdn/15.24.1/img/spell/SummonerHeal.png'); }
        #btn-f { background-image: url('https://ddragon.leagueoflegends.com/cdn/15.24.1/img/spell/SummonerFlash.png'); }
        .skill-box.summoner { width: 32px; height: 32px; margin-top: 10px; }
        .hotkey { position: absolute; bottom: 2px; right: 3px; font-size: 10px; color: #fff; text-shadow: 1px 1px 0 #000; font-weight: bold; pointer-events: none; }
        .bars-container { width: 100%; display: flex; flex-direction: column; gap: 4px; min-width: 260px; }
        .bar-wrapper { position: relative; width: 100%; height: 16px; background: #111; border: 1px solid #000; }
        .hp-fill { background: linear-gradient(to right, #1a9c30, #2bc244); width: 100%; height: 100%; transition: width 0.2s ease-out; }
        .mana-fill { background: linear-gradient(to right, #1a4e9c, #2b6cc2); width: 100%; height: 100%; transition: width 0.2s ease-out; }
        .bar-text { position: absolute; top: 0; left: 50%; transform: translateX(-50%); font-size: 11px; color: #eee; line-height: 16px; text-shadow: 1px 1px 1px #000; white-space: nowrap; font-weight: 500; }
        .damage-number { position: absolute; color: white; font-weight: bold; font-size: 24px; pointer-events: none; text-shadow: 0 0 3px red; animation: floatUp 1s forwards; z-index: 500; }
        .damage-number.mana-refund { color: #00aaff; text-shadow: 0 0 5px blue; font-size: 20px; }
        .damage-number.crit { color: #ff3333; font-size: 36px; text-shadow: 0 0 5px #000; font-family: 'Beaufort for LOL'; }
        @keyframes floatUp { 0% { transform: translateY(0) scale(1); opacity: 1; } 100% { transform: translateY(-50px) scale(1.2); opacity: 0; } }

    </style>
</head>
<body>

    <div id="game-canvas"></div>

    <!-- LOADING SCREEN -->
    <div id="loading-screen">
        <div class="loader-ring"></div>
        <div class="loading-text">SUMMONING CHAMPIONS...</div>
    </div>

    <!-- AUGMENT SELECTION MODAL -->
    <div id="augment-modal">
        <div class="augment-header">Select an Augment</div>
        <div class="cards-container" id="cards-container"></div>
    </div>

    <div id="ui-layer" style="display: none;">
        <!-- NEW SCOREBOARD -->
        <div id="scoreboard">
            <div class="sb-team-wrapper left">
                <div class="sb-team-logo blue"><div class="logo-img" style="background-image: url('https://raw.githubusercontent.com/hiiragimikoto/arena-map-ui/refs/heads/main/poro.png');"></div></div>
                <div class="sb-rows-container">
                    <div class="sb-row">
                        <div class="sb-portrait-group"><div class="sb-portrait" id="sb-p-icon" style="background-image: url('https://ddragon.leagueoflegends.com/cdn/14.1.1/img/champion/Ezreal.png');"></div><div class="sb-lvl" id="sb-p-lvl">1</div></div>
                        <div class="sb-spells-col"><div class="sb-spell" style="background-image: url('https://ddragon.leagueoflegends.com/cdn/15.24.1/img/spell/SummonerFlash.png');"></div><div class="sb-spell" style="background-image: url('https://ddragon.leagueoflegends.com/cdn/15.24.1/img/spell/SummonerHeal.png');"></div></div>
                        <div class="sb-augments-row" id="sb-p-augments"></div>
                        <div class="sb-stats-col"><div class="sb-kda" id="sb-p-kda">0/0/0</div></div>
                    </div>
                </div>
            </div>
            <div class="sb-team-wrapper right">
                <div class="sb-rows-container">
                    <div class="sb-row">
                        <div class="sb-portrait-group"><div class="sb-portrait" id="sb-e-icon" style="background-image: url('https://ddragon.leagueoflegends.com/cdn/14.1.1/img/champion/Ezreal.png');"></div><div class="sb-lvl" id="sb-e-lvl">1</div></div>
                        <div class="sb-spells-col"><div class="sb-spell" style="background-image: url('https://ddragon.leagueoflegends.com/cdn/15.24.1/img/spell/SummonerFlash.png');"></div><div class="sb-spell" style="background-image: url('https://ddragon.leagueoflegends.com/cdn/15.24.1/img/spell/SummonerHeal.png');"></div></div>
                        <div class="sb-augments-row" id="sb-e-augments"></div>
                        <div class="sb-stats-col"><div class="sb-kda" id="sb-e-kda">0/0/0</div></div>
                    </div>
                </div>
                <div class="sb-team-logo red"><div class="logo-img" style="background-image: url('https://raw.githubusercontent.com/hiiragimikoto/arena-map-ui/refs/heads/main/cua.png');"></div></div>
            </div>
        </div>

        <div id="announcement-banner" class="announcement-wrapper">
            <div class="ann-icon" id="ann-left-icon"></div>
            <div class="ann-content" id="ann-bg"><h1 class="ann-text" id="ann-text"></h1><div class="ann-underline" id="ann-line"></div></div>
            <div class="ann-icon" id="ann-right-icon" style="border-color: #d12f2f;"></div>
        </div>

        <div id="minimap">
            <div id="mm-player"></div>
            <div id="mm-enemy"></div>
        </div>

        <div id="player-bar" class="floating-bar">
            <div class="lvl-box" id="p-overhead-lvl">1</div>
            <div class="bars-stack">
                <div class="overhead-hp"><div class="overhead-hp-fill hp-green" id="p-hp-fill"></div></div>
                <div class="overhead-mana"><div class="overhead-mana-fill" id="p-mana-fill"></div></div>
                <div class="cast-bar-container" id="p-cast-bar"><div class="cast-text">Channeling...</div><div class="cast-bar-fill" id="p-cast-fill"></div></div>
            </div>
        </div>

        <div id="enemy-bar" class="floating-bar" style="display: none;">
            <div class="lvl-box" id="e-overhead-lvl" style="border-color: #d12f2f;">1</div>
            <div class="bars-stack">
                <div class="overhead-hp"><div class="overhead-hp-fill hp-red" id="e-hp-fill"></div></div>
                <div class="overhead-mana"><div class="overhead-mana-fill" id="e-mana-fill"></div></div>
                <div class="cast-bar-container" id="e-cast-bar"><div class="cast-text">Channeling...</div><div class="cast-bar-fill" id="e-cast-fill"></div></div>
            </div>
        </div>

        <div class="hud-container interactive-ui">
            <!-- NEW STATS PANEL -->
            <div class="stats-panel">
                <div class="stat-row"><div class="stat-icon icon-ad"></div><span id="stat-ad">0</span></div>
                <div class="stat-row"><div class="stat-icon icon-ap"></div><span id="stat-ap">0</span></div>
                <div class="stat-row"><div class="stat-icon icon-arm"></div><span id="stat-arm">0</span></div>
                <div class="stat-row"><div class="stat-icon icon-mr"></div><span id="stat-mr">0</span></div>
                <div class="stat-row"><div class="stat-icon icon-as"></div><span id="stat-as">0.00</span></div>
                <div class="stat-row"><div class="stat-icon icon-ah"></div><span id="stat-ah">0</span></div>
                <div class="stat-row"><div class="stat-icon icon-crit"></div><span id="stat-crit">0%</span></div>
                <div class="stat-row"><div class="stat-icon icon-ms"></div><span id="stat-ms">0</span></div>
            </div>

            <div class="portrait-container">
                <div class="portrait-circle" id="portrait-circle"><div id="death-timer" class="death-timer-overlay" style="display: none;">5</div></div>
                <div class="level-badge" id="hud-lvl">1</div>
            </div>
            <div class="center-panel">
                <div class="skills-row">
                    <div class="skill-box" id="btn-q"><span class="hotkey">Q</span><div class="cd-timer"></div></div>
                    <div class="skill-box" id="btn-w"><span class="hotkey">W</span><div class="cd-timer"></div></div>
                    <div class="skill-box disabled" id="btn-e"><span class="hotkey">E</span></div>
                    <div class="skill-box disabled" id="btn-r"><span class="hotkey">R</span></div>
                    <div class="skill-box summoner" id="btn-d"><span class="hotkey">D</span><div class="cd-timer"></div></div>
                    <div class="skill-box summoner" id="btn-f"><span class="hotkey">F</span><div class="cd-timer"></div></div>
                </div>
                <div class="bars-container">
                    <div class="bar-wrapper"><div class="hp-fill" id="hp-bar"></div><span class="bar-text" id="hp-text"></span></div>
                    <div class="bar-wrapper"><div class="mana-fill" id="mana-bar"></div><span class="bar-text" id="mana-text"></span></div>
                </div>
            </div>
            <div class="inventory-panel">
                <div class="inv-row"><div class="inv-slot item-green"></div><div class="inv-slot item-sword"></div><div class="inv-slot item-pick"></div></div>
                <div class="inv-row"><div class="inv-slot item-sword"></div><div class="inv-slot"></div><div class="inv-slot"></div></div>
                <div class="gold-display"><div class="gold-icon"></div> <span id="gold-count">2020</span></div>
            </div>
        </div>
    </div>

    <!-- MAIN THREE.JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>

    <script>
        const MAX_LEVEL = 18;
        const MAP_RADIUS = 30;
        const REGEN_PER_SEC = 2.5; 
        const AUGMENT_CAP = 12; 
        
        function getWikiAugmentUrl(name) {
            const safeName = name.replace(/ /g, '_').replace(/'/g, '%27');
            return `https://wiki.leagueoflegends.com/en-us/images/thumb/${safeName}_augment.png/80px-${safeName}_augment.png`;
        }

        const augmentsList = [
            // --- SILVER ---
            { id: 'blunt', name: 'Blunt Force', type: 'Offense', tier: 'silver', desc: 'Gain <span class="aug-stat">10% Attack Damage</span>.', icon: getWikiAugmentUrl('Blunt Force') },
            { id: 'buckle', name: 'Buckle Up', type: 'Defense', tier: 'silver', desc: 'Gain <span class="aug-stat">150 Health</span> and size.', icon: getWikiAugmentUrl('Buckle Up') },
            { id: 'buffet', name: 'Buffet', type: 'Utility', tier: 'silver', desc: 'Gain <span class="aug-stat">Attack Range</span> and <span class="aug-stat">HP Regen</span>.', icon: getWikiAugmentUrl('Buffet') },
            { id: 'contract', name: 'Contract Killer', type: 'Offense', tier: 'silver', desc: 'Deal <span class="aug-stat">5% more damage</span>.', icon: getWikiAugmentUrl('Contract Killer') },
            { id: 'deft', name: 'Deft', type: 'Offense', tier: 'silver', desc: 'Gain <span class="aug-stat">40% Attack Speed</span>.', icon: getWikiAugmentUrl('Deft') },
            { id: 'erosion', name: 'Erosion', type: 'Offense', tier: 'silver', desc: 'Attacks shred enemy armor.', icon: getWikiAugmentUrl('Erosion') },
            { id: 'executioner', name: 'Executioner', type: 'Offense', tier: 'silver', desc: 'Deal <span class="aug-stat">15% more damage</span> to enemies below 50% HP.', icon: getWikiAugmentUrl('Executioner') },
            { id: 'fast', name: 'Fast And Furious', type: 'Utility', tier: 'silver', desc: 'Gain <span class="aug-stat">Skill Haste</span> and <span class="aug-stat">Move Speed</span>.', icon: getWikiAugmentUrl('Fast and Furious') },
            { id: 'fallen', name: 'Fallen Aegis', type: 'Defense', tier: 'silver', desc: 'Start combat with a temporary shield.', icon: getWikiAugmentUrl('Fallen Aegis') },
            { id: 'warmup', name: 'Warmup Routine', type: 'Utility', tier: 'silver', desc: 'Gain <span class="aug-stat">Summoner Haste</span>.', icon: getWikiAugmentUrl('Warmup Routine') },
            { id: 'heavy', name: 'Heavy Hitter', type: 'Offense', tier: 'silver', desc: 'Attacks deal bonus damage equal to <span class="aug-stat">5% Max HP</span>.', icon: getWikiAugmentUrl('Heavy Hitter') },
            { id: 'nowyousee', name: 'Now You See Me', type: 'Utility', tier: 'silver', desc: 'Flash has huge Haste.', icon: getWikiAugmentUrl('Now You See Me') },
            { id: 'shadow', name: 'Shadow Runner', type: 'Utility', tier: 'silver', desc: 'Gain <span class="aug-stat">Move Speed</span>.', icon: getWikiAugmentUrl('Shadow Runner') },
            { id: 'sonic', name: 'Sonic Boom', type: 'Offense', tier: 'silver', desc: 'Buffs (Heal/Flash) deal damage to nearby enemies.', icon: getWikiAugmentUrl('Sonic Boom') },
            { id: 'tormentor', name: 'Tormentor', type: 'Offense', tier: 'silver', desc: 'Immobilizing (or Hitting) applies a DoT burn.', icon: getWikiAugmentUrl('Tormentor') },
            { id: 'virtuous', name: 'Virtuous Cycle', type: 'Utility', tier: 'silver', desc: 'Heals grant shield capacity.', icon: getWikiAugmentUrl('Virtuous Cycle') },
            { id: 'vulnerability', name: 'Vulnerability', type: 'Offense', tier: 'silver', desc: 'Items and DoT effects can Crit.', icon: getWikiAugmentUrl('Vulnerability') },
            
            // --- GOLD ---
            { id: 'apex', name: 'Apex Inventor', type: 'Utility', tier: 'gold', desc: 'Gain massive <span class="aug-stat">Item Haste</span> (Skills CD Reduced).', icon: getWikiAugmentUrl('Apex Inventor') },
            { id: 'banner', name: 'Banner of Command', type: 'Utility', tier: 'gold', desc: 'Gain HP and stats.', icon: getWikiAugmentUrl('Banner of Command') },
            { id: 'breadbutter', name: 'Bread And Butter', type: 'Offense', tier: 'gold', desc: 'Your Q has <span class="aug-stat">150 Ability Haste</span>.', icon: getWikiAugmentUrl('Bread And Butter') },
            { id: 'breadjam', name: 'Bread And Jam', type: 'Utility', tier: 'gold', desc: 'Your W has <span class="aug-stat">150 Ability Haste</span>.', icon: getWikiAugmentUrl('Bread And Jam') },
            { id: 'brutalizer', name: 'The Brutalizer', type: 'Offense', tier: 'gold', desc: 'Gain <span class="aug-stat">25 AD</span> and <span class="aug-stat">10 Haste</span>.', icon: getWikiAugmentUrl('The Brutalizer') },
            { id: 'cannon', name: 'Cannon Fodder', type: 'Utility', tier: 'gold', desc: 'Enter combat via cannon (Start with Speed Boost).', icon: getWikiAugmentUrl('Cannon Fodder') },
            { id: 'celestial', name: 'Celestial Body', type: 'Defense', tier: 'gold', desc: 'Gain <span class="aug-stat">1000 HP</span>, but deal -10% Damage.', icon: getWikiAugmentUrl('Celestial Body') },
            { id: 'combo', name: 'Combo Master', type: 'Offense', tier: 'gold', desc: 'Gain Move Speed and Haste after casting.', icon: getWikiAugmentUrl('Combo Master') },
            { id: 'dawn', name: 'Dawnbringer\'s Resolve', type: 'Defense', tier: 'gold', desc: 'When dropping below 50% HP, heal for 30% Max HP (15s CD).', icon: getWikiAugmentUrl('Dawnbringer\'s Resolve') },
            { id: 'dieanother', name: 'Die Another Day', type: 'Defense', tier: 'gold', desc: 'Summoner Spells heal you.', icon: getWikiAugmentUrl('Die Another Day') },
            { id: 'beginning', name: 'From Beginning to End', type: 'Offense', tier: 'gold', desc: 'First strike and Last strike deal bonus damage.', icon: getWikiAugmentUrl('From Beginning to End') },
            { id: 'firebrand', name: 'Firebrand', type: 'Offense', tier: 'gold', desc: 'Attacks burn enemies.', icon: getWikiAugmentUrl('Firebrand') },
            { id: 'holyfire', name: 'Holy Fire', type: 'Utility', tier: 'gold', desc: 'Heals damage nearby enemies.', icon: getWikiAugmentUrl('Holy Fire') },
            { id: 'crit', name: 'It\'s Critical', type: 'Offense', tier: 'gold', desc: 'Gain <span class="aug-stat">40% Crit Chance</span>.', icon: getWikiAugmentUrl('It\'s Critical') },
            { id: 'twice', name: 'Lightning Strikes', type: 'Offense', tier: 'gold', desc: 'Every 3rd attack strikes again with bonus Attack Speed.', icon: getWikiAugmentUrl('Lightning Strikes') },
            { id: 'marksmage', name: 'Marksmage', type: 'Offense', tier: 'gold', desc: 'Attacks deal bonus damage based on Ability Power.', icon: getWikiAugmentUrl('Marksmage') },
            { id: 'mind', name: 'Mind to Matter', type: 'Defense', tier: 'gold', desc: 'Gain Health equal to <span class="aug-stat">50%</span> of your Mana.', icon: getWikiAugmentUrl('Mind to Matter') },
            { id: 'outlaw', name: 'Outlaw\'s Grit', type: 'Defense', tier: 'gold', desc: 'Gain Resists after using movement skills.', icon: getWikiAugmentUrl('Outlaw\'s Grit') },
            { id: 'perseverance', name: 'Perseverance', type: 'Defense', tier: 'gold', desc: 'Gain <span class="aug-stat">Massive HP Regen</span>, increasing when low.', icon: getWikiAugmentUrl('Perseverance') },
            { id: 'rabble', name: 'Rabble Rousing', type: 'Utility', tier: 'gold', desc: 'Using an ability heals you for <span class="aug-stat">2% Max HP</span>.', icon: getWikiAugmentUrl('Rabble Rousing') },
            { id: 'scoped', name: 'Scopier Weapons', type: 'Offense', tier: 'gold', desc: 'Gain <span class="aug-stat">200 Attack Range</span>.', icon: getWikiAugmentUrl('Scopier Weapons') },
            { id: 'shrink', name: 'Shrink Ray', type: 'Defense', tier: 'gold', desc: 'Attacks reduce enemy damage.', icon: getWikiAugmentUrl('Shrink Ray') },
            { id: 'thread', name: 'Thread the Needle', type: 'Offense', tier: 'gold', desc: 'Gain Armor Pen.', icon: getWikiAugmentUrl('Thread the Needle') },

            // --- PRISMATIC ---
            { id: 'accelerating', name: 'Accelerating Sorcery', type: 'Offense', tier: 'prismatic', desc: 'Using skills grants infinite stacking Haste.', icon: getWikiAugmentUrl('Accelerating Sorcery') },
            { id: 'blade', name: 'Blade Waltz', type: 'Offense', tier: 'prismatic', desc: 'Gain massive AS and Haste.', icon: getWikiAugmentUrl('Blade Waltz') },
            { id: 'chain', name: 'Chain Lightning', type: 'Offense', tier: 'prismatic', desc: 'Attacks chain to enemies.', icon: getWikiAugmentUrl('Chain Lightning') },
            { id: 'courage', name: 'Courage of the Colossus', type: 'Defense', tier: 'prismatic', desc: 'Gain a massive shield after CC.', icon: getWikiAugmentUrl('Courage of the Colossus') },
            { id: 'dragonheart', name: 'Dragonheart', type: 'Utility', tier: 'prismatic', desc: 'Gain Elder Dragon stats.', icon: getWikiAugmentUrl('Dragonheart') },
            { id: 'earthwake', name: 'Earthwake', type: 'Offense', tier: 'prismatic', desc: 'Movement skills leave an exploding trail.', icon: getWikiAugmentUrl('Earthwake') },
            { id: 'eureka', name: 'Eureka', type: 'Utility', tier: 'prismatic', desc: 'Gain Haste equal to 20% of AP/AD.', icon: getWikiAugmentUrl('Eureka') },
            { id: 'giant', name: 'Giant Slayer', type: 'Offense', tier: 'prismatic', desc: 'Become small. Deal more damage to big enemies.', icon: getWikiAugmentUrl('Giant Slayer') },
            { id: 'goliath', name: 'Goliath', type: 'Defense', tier: 'prismatic', desc: 'Become Huge. Gain <span class="aug-stat">35% HP</span> and <span class="aug-stat">15% AD</span>.', icon: getWikiAugmentUrl('Goliath') },
            { id: 'goredrink', name: 'Goredrink', type: 'Defense', tier: 'prismatic', desc: 'Gain <span class="aug-stat">Omnivamp</span> and <span class="aug-stat">Health</span>.', icon: getWikiAugmentUrl('Goredrink') },
            { id: 'infernal', name: 'Infernal Conduit', type: 'Offense', tier: 'prismatic', desc: 'Attacks apply burn and reduce cooldowns.', icon: getWikiAugmentUrl('Infernal Conduit') },
            { id: 'jeweled', name: 'Jeweled Gauntlet', type: 'Offense', tier: 'prismatic', desc: 'Abilities can Crit. Gain Crit Chance.', icon: getWikiAugmentUrl('Jeweled Gauntlet') },
            { id: 'mad', name: 'Mad Scientist', type: 'Offense', tier: 'prismatic', desc: 'Gain random stats (AD/HP/Haste).', icon: getWikiAugmentUrl('Mad Scientist') },
            { id: 'mystic', name: 'Mystic Punch', type: 'Offense', tier: 'prismatic', desc: 'Attacks reduce all cooldowns by 1s.', icon: getWikiAugmentUrl('Mystic Punch') },
            { id: 'omni', name: 'Omni Soul', type: 'Utility', tier: 'prismatic', desc: 'Gain 3 Random Dragon Souls.', icon: getWikiAugmentUrl('Omni Soul') },
            { id: 'quantum', name: 'Quantum Computing', type: 'Utility', tier: 'prismatic', desc: 'Augments act faster (Haste).', icon: getWikiAugmentUrl('Quantum Computing') },
            { id: 'spirit', name: 'Spirit Link', type: 'Defense', tier: 'prismatic', desc: 'Damage taken is redirected.', icon: getWikiAugmentUrl('Spirit Link') },
            { id: 'symphony', name: 'Symphony of War', type: 'Offense', tier: 'prismatic', desc: 'Gain Stacking Attack Speed and AD.', icon: getWikiAugmentUrl('Symphony of War') },
            { id: 'tap', name: 'Tap Dancer', type: 'Utility', tier: 'prismatic', desc: 'Attacks grant Move Speed. AS is uncapped.', icon: getWikiAugmentUrl('Tap Dancer') },
            { id: 'typhoon', name: 'Typhoon', type: 'Offense', tier: 'prismatic', desc: 'Attacks fire bolts at nearby enemies.', icon: getWikiAugmentUrl('Typhoon') }
        ];

        let isSelecting = false;
        let gameStarted = false;

        function createStats() {
            return {
                maxHp: 600, curHp: 600, maxMana: 375, curMana: 375, 
                baseDmg: 60, damage: 60, range: 8, attackSpeed: 1000, lastAttack: 0, 
                level: 1, 
                cooldowns: { q: 0, w:0, d: 0, f: 0 }, 
                kills: 0, deaths: 0, cs: 0, gold: 0, 
                wMark: { active: false, mesh: null }, 
                augments: [], 
                // Augment Flags & Mods
                critChance: 0, critDmg: 1.5,
                haste: 0, qHaste: 0, wHaste: 0,
                hpRegenMod: 1.0, lifesteal: 0,
                scale: 1.0, dmgMult: 1.0, defenseMult: 1.0, moveSpeedMod: 1.0,
                // Specific Flags
                hasTyphoon: false, hasTwice: false, attackCount: 0,
                hasTap: false, tapStacks: 0,
                hasMystic: false, hasRestless: false, hasRabble: false,
                hasHeavy: false, hasMind: false, hasLightning: false,
                hasDawn: false, dawnCd: 0,
                hasInfernal: false, hasBurn: false,
                hasEarthwake: false, hasSonic: false,
                hasAccelerating: false, accStacks: 0,
                hasSymphony: false, symStacks: 0,
                distanceMoved: 0
            };
        }

        const player = createStats();
        const enemy = createStats();
        enemy.attackSpeed = 1500; 

        // Base Spells (Speed in units/sec)
        const spells = {
            q: { cd: 4000, mana: 35, width: 2.0, range: 35, speed: 70, castTime: 250 }, 
            w: { cd: 12000, mana: 50, width: 3.0, range: 35, speed: 60, castTime: 250 },
            d: { cd: 45000, heal: 300 }, 
            f: { cd: 30000, dist: 8 }    
        };

        function getCooldown(baseCD, haste) { return baseCD / (1 + haste/100); }
        
        function getQDamage(level, stats) { 
            let dmg = (20 + (5 * (level - 1)) + stats.damage * 1.1) * stats.dmgMult; 
            if (stats.augments.some(a => a.id === 'jeweled' || a.id === 'vulnerability')) {
                if (Math.random() < stats.critChance) dmg *= stats.critDmg;
            }
            return dmg;
        }

        function getWDamage(level, stats) { 
            let dmg = (80 + (55 * (level - 1)) + stats.damage * 0.6) * stats.dmgMult;
            if (stats.augments.some(a => a.id === 'jeweled')) {
                if (Math.random() < stats.critChance) dmg *= stats.critDmg;
            }
            return dmg;
        }

        let isDead = false;
        let isEnemyDead = false;
        let pChannel = { active: false, start: 0, duration: 0, onComplete: null };
        let eChannel = { active: false, start: 0, duration: 0, onComplete: null };
        let skillshots = [];
        let particles = [];
        
        function showAugmentSelection() {
            if (player.augments.length >= AUGMENT_CAP) return;
            isSelecting = true;
            document.getElementById('augment-modal').style.display = 'flex';
            generateAugmentCards();
        }

        function generateAugmentCards() {
            const container = document.getElementById('cards-container');
            container.innerHTML = '';
            const shuffled = [...augmentsList].sort(() => 0.5 - Math.random());
            const picked = shuffled.slice(0, 3);
            picked.forEach(aug => {
                const card = document.createElement('div');
                card.className = `augment-card card-${aug.tier}`;
                const imgUrl = aug.icon;
                card.innerHTML = `
                    <div class="card-border-frame"></div>
                    <div class="aug-img-container"><div class="aug-icon-wrapper"><div class="aug-tier-bg"></div><div class="aug-icon" style="background-image: url('${imgUrl}');"></div></div></div>
                    <div class="aug-content"><div class="aug-name">${aug.name}</div><div class="aug-type-badge">${aug.type}</div><div class="aug-desc">${aug.desc}</div></div>
                `;
                card.onclick = () => selectAugment(aug);
                container.appendChild(card);
            });
        }

        function selectAugment(aug) {
            player.augments.push(aug);
            applyAugmentEffect(aug.id, player, pMesh);
            giveEnemyRandomAugment();
            isSelecting = false;
            document.getElementById('augment-modal').style.display = 'none';
            updateUI(); 
        }

        function giveEnemyRandomAugment() {
            if (enemy.augments.length >= AUGMENT_CAP) return;
            const randomAug = augmentsList[Math.floor(Math.random() * augmentsList.length)];
            enemy.augments.push(randomAug);
            applyAugmentEffect(randomAug.id, enemy, eMesh);
        }

        function applyAugmentEffect(id, stats, mesh) {
            switch(id) {
                // SILVER
                case 'blunt': stats.damage += stats.baseDmg * 0.1; break;
                case 'buckle': stats.maxHp += 150; stats.curHp += 150; stats.scale *= 1.1; break;
                case 'buffet': stats.range += 2; stats.hpRegenMod += 1.0; break;
                case 'contract': stats.dmgMult *= 1.05; break;
                case 'deft': stats.attackSpeed *= 0.6; break;
                case 'erosion': stats.dmgMult *= 1.05; break;
                case 'executioner': break;
                case 'fast': stats.haste += 10; stats.moveSpeedMod += 0.1; break;
                case 'fallen': stats.maxHp += 100; stats.curHp += 100; break;
                case 'warmup': stats.haste += 10; break;
                case 'heavy': stats.hasHeavy = true; break;
                case 'nowyousee': stats.haste += 15; break;
                case 'shadow': stats.moveSpeedMod += 0.15; break;
                case 'sonic': stats.hasSonic = true; break;
                case 'tormentor': stats.hasBurn = true; break;
                case 'virtuous': stats.maxHp += 100; break;
                case 'vulnerability': stats.critChance += 0.2; stats.critDmg += 0.1; break;

                // GOLD
                case 'apex': stats.haste += 30; break;
                case 'banner': stats.maxHp += 200; stats.curHp += 200; break;
                case 'breadbutter': stats.qHaste += 150; break;
                case 'breadjam': stats.wHaste += 150; break;
                case 'brutalizer': stats.damage += 25; stats.haste += 10; break;
                case 'cannon': stats.moveSpeedMod += 0.2; break; 
                case 'celestial': stats.maxHp += 1000; stats.curHp += 1000; stats.dmgMult *= 0.9; break;
                case 'combo': stats.haste += 10; stats.moveSpeedMod += 0.1; break;
                case 'dawn': stats.hasDawn = true; break;
                case 'dieanother': break;
                case 'beginning': stats.dmgMult *= 1.1; break;
                case 'firebrand': stats.hasBurn = true; break;
                case 'holyfire': stats.hasSonic = true; break;
                case 'crit': stats.critChance += 0.4; break;
                case 'twice': case 'lightning': stats.hasTwice = true; stats.attackSpeed *= 0.8; break;
                case 'marksmage': stats.damage += 30; break;
                case 'mind': stats.hasMind = true; stats.maxHp += stats.maxMana * 0.5; stats.curHp += stats.maxMana * 0.5; break;
                case 'outlaw': stats.maxHp += 150; break;
                case 'perseverance': stats.hpRegenMod += 5.0; break;
                case 'rabble': stats.hasRabble = true; break;
                case 'scoped': stats.range += 4; break;
                case 'shrink': stats.defenseMult *= 0.85; break;
                case 'thread': stats.dmgMult *= 1.15; break;

                // PRISMATIC
                case 'accelerating': stats.hasAccelerating = true; break;
                case 'blade': stats.attackSpeed *= 0.5; stats.haste += 30; break;
                case 'chain': case 'typhoon': stats.hasTyphoon = true; break;
                case 'courage': stats.maxHp += 400; stats.curHp += 400; break;
                case 'dragonheart': stats.damage *= 1.1; stats.maxHp *= 1.1; stats.haste += 10; break;
                case 'earthwake': stats.hasEarthwake = true; break;
                case 'eureka': stats.haste += 40; break;
                case 'giant': stats.scale *= 0.7; stats.dmgMult *= 1.25; break;
                case 'goliath': stats.maxHp *= 1.35; stats.curHp *= 1.35; stats.damage *= 1.15; stats.scale *= 1.4; break;
                case 'goredrink': stats.lifesteal += 0.15; stats.maxHp += 300; break;
                case 'infernal': stats.hasInfernal = true; stats.hasBurn = true; break;
                case 'jeweled': stats.critChance += 0.2; stats.dmgMult *= 1.1; break; 
                case 'mad': stats.damage += 20; stats.maxHp += 200; stats.haste += 10; break;
                case 'mystic': stats.hasMystic = true; break;
                case 'omni': stats.hpRegenMod += 2; stats.haste += 10; stats.damage *= 1.05; break;
                case 'quantum': stats.haste += 40; break;
                case 'spirit': stats.defenseMult *= 0.8; break;
                case 'symphony': stats.hasSymphony = true; break;
                case 'tap': stats.hasTap = true; break;
            }
            if(mesh) mesh.scale.set(stats.scale, stats.scale, stats.scale);
        }

        const ui = {
            hpBar: document.getElementById('hp-bar'), hpText: document.getElementById('hp-text'), manaBar: document.getElementById('mana-bar'), manaText: document.getElementById('mana-text'), hudLvl: document.getElementById('hud-lvl'), portrait: document.getElementById('portrait-circle'), deathTimer: document.getElementById('death-timer'), pOverhead: document.getElementById('player-bar'), pHp: document.getElementById('p-hp-fill'), pMana: document.getElementById('p-mana-fill'), pLvl: document.getElementById('p-overhead-lvl'), pCastBar: document.getElementById('p-cast-bar'), pCastFill: document.getElementById('p-cast-fill'), eOverhead: document.getElementById('enemy-bar'), eHp: document.getElementById('e-hp-fill'), eMana: document.getElementById('e-mana-fill'), eLvl: document.getElementById('e-overhead-lvl'), eCastBar: document.getElementById('e-cast-bar'), eCastFill: document.getElementById('e-cast-fill'), ann: document.getElementById('announcement-banner'), annText: document.getElementById('ann-text'), annLeft: document.getElementById('ann-left-icon'), annRight: document.getElementById('ann-right-icon'), 
            btnQ: document.getElementById('btn-q'), btnW: document.getElementById('btn-w'), btnD: document.getElementById('btn-d'), btnF: document.getElementById('btn-f'), 
            scoreboard: document.getElementById('scoreboard'), 
            sbPKda: document.getElementById('sb-p-kda'), sbPLvl: document.getElementById('sb-p-lvl'),
            sbEKda: document.getElementById('sb-e-kda'), sbELvl: document.getElementById('sb-e-lvl'),
            sbPAugs: document.getElementById('sb-p-augments'), sbEAugs: document.getElementById('sb-e-augments'), gold: document.getElementById('gold-count'),
            mmPlayer: document.getElementById('mm-player'), mmEnemy: document.getElementById('mm-enemy'),
            // Stats Panel Elements
            stAd: document.getElementById('stat-ad'), stAp: document.getElementById('stat-ap'), stArm: document.getElementById('stat-arm'), stMr: document.getElementById('stat-mr'),
            stAs: document.getElementById('stat-as'), stAh: document.getElementById('stat-ah'), stCrit: document.getElementById('stat-crit'), stMs: document.getElementById('stat-ms')
        };

        function updateUI() {
            if (!gameStarted) return;
            // Update Max HP logic
            if(player.hasMind) {
                const mindBonus = player.maxMana * 0.5;
                const baseHp = 600 + (70 * (player.level-1));
                let augHp = 0;
                player.augments.forEach(a => {
                   if(a.id=='buckle') augHp+=150; if(a.id=='fallen') augHp+=100; if(a.id=='banner') augHp+=200;
                   if(a.id=='celestial') augHp+=1000; 
                   if(a.id=='goredrink') augHp+=300; if(a.id=='courage') augHp+=400; if(a.id=='mad') augHp+=200;
                });
                player.maxHp = (baseHp + augHp + mindBonus) * (player.augments.find(a=>a.id=='goliath') ? 1.35 : 1);
            }

            player.curHp = Math.max(0, Math.min(player.curHp, player.maxHp)); player.curMana = Math.max(0, Math.min(player.curMana, player.maxMana)); enemy.curHp = Math.max(0, Math.min(enemy.curHp, enemy.maxHp));
            const hpPct = (player.curHp / player.maxHp) * 100, manaPct = (player.curMana / player.maxMana) * 100;
            ui.hpBar.style.width = `${hpPct}%`; ui.hpText.innerText = `${Math.floor(player.curHp)}/${Math.floor(player.maxHp)}`; ui.manaBar.style.width = `${manaPct}%`; ui.manaText.innerText = `${Math.floor(player.curMana)}/${Math.floor(player.maxMana)}`; ui.hudLvl.innerText = player.level; ui.pHp.style.width = `${hpPct}%`; ui.pMana.style.width = `${manaPct}%`; ui.pLvl.innerText = player.level;
            const eHpPct = (enemy.curHp / enemy.maxHp) * 100, eManaPct = (enemy.curMana / enemy.maxMana) * 100;
            ui.eHp.style.width = `${eHpPct}%`; ui.eMana.style.width = `${eManaPct}%`; ui.eLvl.innerText = enemy.level;
            
            updateCD(ui.btnQ, player.cooldowns.q, getCooldown(spells.q.cd, player.haste + player.qHaste)); 
            updateCD(ui.btnW, player.cooldowns.w, getCooldown(spells.w.cd, player.haste + player.wHaste)); 
            updateCD(ui.btnD, player.cooldowns.d, getCooldown(spells.d.cd, player.haste)); 
            updateCD(ui.btnF, player.cooldowns.f, getCooldown(spells.f.cd, player.haste));
            
            updateChannelUI(pChannel, ui.pCastBar, ui.pCastFill); updateChannelUI(eChannel, ui.eCastBar, ui.eCastFill);
            ui.gold.innerText = player.gold;

            // UPDATE STAT PANEL
            ui.stAd.innerText = Math.floor(player.damage * player.dmgMult); // Approx AD
            ui.stAp.innerText = 0; // Ezreal here is AD only
            // Simulate Armor based on defense mult (1.0 = 0 armor, 0.5 = 100 armor)
            let simArmor = Math.floor((1 / player.defenseMult - 1) * 100); 
            if(simArmor < 0) simArmor = 0;
            ui.stArm.innerText = 40 + simArmor; // Base 40
            ui.stMr.innerText = 30;
            ui.stAs.innerText = (1000 / player.attackSpeed).toFixed(2);
            ui.stAh.innerText = Math.floor(player.haste);
            ui.stCrit.innerText = Math.floor(player.critChance * 100) + '%';
            ui.stMs.innerText = Math.floor(325 * player.moveSpeedMod);
        }

        function updateChannelUI(chObj, container, fill) {
            if (chObj.active) { container.style.display = 'block'; const progress = Math.min(1, (Date.now() - chObj.start) / chObj.duration); fill.style.width = (progress * 100) + '%'; } else { container.style.display = 'none'; fill.style.width = '0%'; }
        }

        function updateScoreboardData() {
            ui.sbPKda.innerText = `${player.kills}/${player.deaths}/${0}`; ui.sbPLvl.innerText = player.level;
            ui.sbEKda.innerText = `${enemy.kills}/${enemy.deaths}/${0}`; ui.sbELvl.innerText = enemy.level;
            renderAugmentIcons(ui.sbPAugs, player.augments); renderAugmentIcons(ui.sbEAugs, enemy.augments);
        }

        function renderAugmentIcons(container, augments) {
            container.innerHTML = '';
            augments.forEach(aug => {
                const div = document.createElement('div'); div.className = 'sb-aug-icon'; div.style.backgroundImage = `url('${aug.icon}')`; container.appendChild(div);
            });
        }

        function updateCD(btn, timestamp, cdDur) {
            const now = Date.now(), remain = timestamp + cdDur - now, textDiv = btn.querySelector('.cd-timer');
            if (remain > 0) { btn.classList.add('cd-active'); textDiv.innerText = (remain / 1000).toFixed(1); } else { btn.classList.remove('cd-active'); textDiv.innerText = ""; }
        }

        function showDamage(val, x, y, isMana, isHeal, isCrit) {
            const div = document.createElement('div'); 
            div.className = isMana ? 'damage-number mana-refund' : (isCrit ? 'damage-number crit' : 'damage-number'); 
            if (isHeal) div.style.color = '#00ff00'; 
            div.innerText = val + (isCrit ? '!' : ''); 
            div.style.left = x + 'px'; div.style.top = y + 'px'; 
            document.body.appendChild(div); 
            setTimeout(() => div.remove(), 1000);
        }

        function gainLevel(stats) { if(stats.level < MAX_LEVEL) { stats.level++; stats.maxHp += 70; stats.maxMana += 50; stats.curHp += 70; stats.curMana += 50; } }

        function announce(playerWon) {
            ui.ann.style.display = 'flex'; ui.ann.style.animation = 'none'; void ui.ann.offsetWidth; ui.ann.style.animation = 'slideDownFade 0.5s ease-out forwards';
            if(playerWon) { ui.ann.classList.remove('ann-red'); ui.annText.innerText = "You have slain an enemy!"; ui.annLeft.style.borderColor = "#c8aa6e"; ui.annRight.style.borderColor = "#d12f2f"; } else { ui.ann.classList.add('ann-red'); ui.annText.innerText = "You have been slain"; ui.annLeft.style.borderColor = "#d12f2f"; ui.annRight.style.borderColor = "#c8aa6e"; }
            setTimeout(() => { ui.ann.style.animation = 'fadeOut 0.5s forwards'; setTimeout(() => ui.ann.style.display = 'none', 500); }, 3000);
        }

        const scene = new THREE.Scene(); scene.background = new THREE.Color(0x87CEEB); scene.fog = new THREE.Fog(0x87CEEB, 30, 100);
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 1000); camera.position.set(0, 35, 35); camera.lookAt(0, 0, 0);
        const renderer = new THREE.WebGLRenderer({ antialias: true }); renderer.setSize(window.innerWidth, window.innerHeight); renderer.shadowMap.enabled = true; document.getElementById('game-canvas').appendChild(renderer.domElement);
        scene.add(new THREE.AmbientLight(0xffffff, 0.7)); const dl = new THREE.DirectionalLight(0xfffaed, 1.2); dl.position.set(20, 50, 20); dl.castShadow = true; scene.add(dl);
        const plane = new THREE.Mesh(new THREE.PlaneGeometry(100, 100), new THREE.MeshBasicMaterial({ visible: false })); plane.rotation.x = -Math.PI/2; scene.add(plane);
        
        const loadingManager = new THREE.LoadingManager();
        loadingManager.onLoad = function ( ) {
            const screen = document.getElementById('loading-screen');
            screen.style.opacity = '0';
            setTimeout(() => { 
                screen.style.display = 'none'; 
                document.getElementById('ui-layer').style.display = 'block';
                gameStarted = true;
                respawn(true); respawn(false);
                showAugmentSelection();
            }, 500);
        };

        const pMesh = new THREE.Mesh(new THREE.BoxGeometry(0.9, 2.2, 0.9), new THREE.MeshStandardMaterial({ color: 0x0088ff })); pMesh.position.set(0, 1.1, 0); pMesh.castShadow = true; scene.add(pMesh);
        const eMesh = new THREE.Mesh(new THREE.BoxGeometry(0.9, 2.2, 0.9), new THREE.MeshStandardMaterial({ color: 0xff3333 })); eMesh.position.set(10, 1.1, 10); eMesh.castShadow = true; scene.add(eMesh);
        const MODEL_URL = 'https://raw.githubusercontent.com/hiiragimikoto/ezreal-model/main/ezreal.glb'; 
        const MAP_URL = 'https://raw.githubusercontent.com/hiiragimikoto/arena-map/main/league%20arena%203d%20model-compressed.glb';
        const loader = new THREE.GLTFLoader(loadingManager);

        loader.load(MAP_URL, function(gltf) {
            const mapModel = gltf.scene; const wrapper = new THREE.Object3D(); scene.add(wrapper);
            const box = new THREE.Box3().setFromObject(mapModel); const center = new THREE.Vector3(); box.getCenter(center); const size = new THREE.Vector3(); box.getSize(size);
            mapModel.position.copy(center).negate(); wrapper.add(mapModel); mapModel.rotation.y = Math.PI;
            const targetDiameter = MAP_RADIUS * 3; const scale = targetDiameter / Math.max(size.x, size.z);
            wrapper.scale.set(scale, scale, scale); wrapper.position.y = 4.5;
            mapModel.traverse(function(node) { if (node.isMesh) node.receiveShadow = true; });
        });
        
        const pAnim = { mixer: null, actions: {}, locked: false, active: null }; const eAnim = { mixer: null, actions: {}, locked: false, active: null };
        function setupModel(gltf, mesh, animData) {
            const model = gltf.scene; const box = new THREE.Box3().setFromObject(model); const size = new THREE.Vector3(); box.getSize(size); const scaleFactor = 3.0 / size.y;
            model.scale.set(scaleFactor, scaleFactor, scaleFactor); model.position.y = -1.1; mesh.add(model); mesh.material.visible = false; 
            animData.mixer = new THREE.AnimationMixer(model); animData.mixer.addEventListener('finished', (e) => { if (e.action === animData.actions.atk || e.action === animData.actions.q || e.action === animData.actions.w) animData.locked = false; });
            const findAnim = (name) => gltf.animations.find(a => a.name.toLowerCase().includes(name));
            animData.actions.idle = animData.mixer.clipAction(findAnim('idle_base') || gltf.animations[0]); animData.actions.run = animData.mixer.clipAction(findAnim('ezreal_run') || gltf.animations[1]);
            animData.actions.atk = animData.mixer.clipAction(findAnim('spell1')); if(animData.actions.atk) { animData.actions.atk.setLoop(THREE.LoopOnce); animData.actions.atk.clampWhenFinished = true; }
            animData.actions.q = animData.mixer.clipAction(findAnim('spell4')); if(animData.actions.q) { animData.actions.q.setLoop(THREE.LoopOnce); animData.actions.q.clampWhenFinished = true; }
            animData.actions.w = animData.mixer.clipAction(findAnim('spell2')); if(animData.actions.w) { animData.actions.w.setLoop(THREE.LoopOnce); animData.actions.w.clampWhenFinished = true; }
            animData.actions.idle.play(); animData.active = animData.actions.idle;
        }
        loader.load(MODEL_URL, function (gltf) { setupModel(gltf, pMesh, pAnim); loader.load(MODEL_URL, function (gltf2) { setupModel(gltf2, eMesh, eAnim); }); });

        const clock = new THREE.Clock(); 
        let projectiles = [];

        function playLockedAnimation(animData, action) { if (!action) return; if (animData.active && animData.active !== action) animData.active.fadeOut(0.1); animData.locked = true; action.reset().play(); animData.active = action; }
        function updateAnimState(animData, moving) { if(!animData.mixer || animData.locked) return; const desired = moving ? animData.actions.run : animData.actions.idle; if(desired && animData.active !== desired) { if(animData.active) animData.active.fadeOut(0.2); desired.reset().fadeIn(0.2).play(); animData.active = desired; } }
        function startChannel(mesh, chObj, duration, onComplete) { chObj.active = true; chObj.start = Date.now(); chObj.duration = duration; chObj.onComplete = onComplete; if (mesh === pMesh) { targetPosition.copy(pMesh.position); lockedTarget = null; } }
        function checkChannels() { const now = Date.now(); if(pChannel.active && now - pChannel.start >= pChannel.duration) { pChannel.active = false; if(pChannel.onComplete) pChannel.onComplete(); } if(eChannel.active && now - eChannel.start >= eChannel.duration) { eChannel.active = false; if(eChannel.onComplete) eChannel.onComplete(); } }

        function onAbilityUse(stats) { 
            if(stats.hasRabble) { const heal = stats.maxHp * 0.02; stats.curHp = Math.min(stats.maxHp, stats.curHp + heal); }
            if(stats.hasAccelerating) { stats.accStacks++; stats.haste += 1; }
        }

        function tryCastQ(caster, stats, rawTargetPos) {
            const chObj = (caster === pMesh) ? pChannel : eChannel, animData = (caster === pMesh) ? pAnim : eAnim; if (chObj.active) return; 
            if (Date.now() - stats.cooldowns.q < getCooldown(spells.q.cd, stats.haste + stats.qHaste) || stats.curMana < spells.q.mana) return;
            const targetPos = rawTargetPos.clone(); caster.lookAt(targetPos); playLockedAnimation(animData, animData.actions.q);
            onAbilityUse(stats);
            if(stats.hasSonic) spawnSonicBoom(caster.position);
            startChannel(caster, chObj, spells.q.castTime, () => { stats.curMana -= spells.q.mana; stats.cooldowns.q = Date.now(); spawnMysticShot(caster, targetPos, stats === player, stats.level); updateUI(); }); updateUI();
        }
        function tryCastW(caster, stats, rawTargetPos) {
            const chObj = (caster === pMesh) ? pChannel : eChannel, animData = (caster === pMesh) ? pAnim : eAnim; if (chObj.active) return; 
            if (Date.now() - stats.cooldowns.w < getCooldown(spells.w.cd, stats.haste + stats.wHaste) || stats.curMana < spells.w.mana) return;
            const targetPos = rawTargetPos.clone(); caster.lookAt(targetPos); playLockedAnimation(animData, animData.actions.w || animData.actions.q);
            onAbilityUse(stats);
            if(stats.hasSonic) spawnSonicBoom(caster.position);
            startChannel(caster, chObj, spells.w.castTime, () => { stats.curMana -= spells.w.mana; stats.cooldowns.w = Date.now(); spawnEssenceFlux(caster, targetPos, stats === player, stats.level); updateUI(); }); updateUI();
        }

        function spawnMysticShot(caster, targetPos, isPlayer, level) {
            const origin = caster.position.clone(); origin.y = 1.5; const direction = new THREE.Vector3().subVectors(targetPos, origin).normalize(); direction.y = 0;
            const mesh = new THREE.Group(); mesh.position.copy(origin); mesh.lookAt(origin.clone().add(direction));
            const head = new THREE.Mesh(new THREE.SphereGeometry(0.3, 16, 16), new THREE.MeshBasicMaterial({ color: 0xffffff })); mesh.add(head);
            const glow = new THREE.Mesh(new THREE.CylinderGeometry(0.35, 0.35, 1.0, 16), new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.8, blending: THREE.AdditiveBlending })); glow.rotateX(-Math.PI/2); mesh.add(glow);
            const trail = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.0, 4.0, 16), new THREE.MeshBasicMaterial({ color: 0x0088ff, transparent: true, opacity: 0.5, blending: THREE.AdditiveBlending })); trail.rotateX(-Math.PI/2); trail.translateZ(-2); mesh.add(trail);
            const light = new THREE.PointLight(0x00ffff, 1.0, 10); mesh.add(light); scene.add(mesh);
            const stats = isPlayer ? player : enemy; const dmg = getQDamage(level, stats);
            skillshots.push({ mesh: mesh, dir: direction, speed: spells.q.speed, range: spells.q.range + (stats.range > 8 ? stats.range : 0), traveled: 0, damage: dmg, isPlayer: isPlayer, radius: spells.q.width/2, type: 'Q', emitParticles: true });
        }
        function spawnEssenceFlux(caster, targetPos, isPlayer, level) {
            const origin = caster.position.clone(); origin.y = 1.5; const direction = new THREE.Vector3().subVectors(targetPos, origin).normalize(); direction.y = 0; const mesh = new THREE.Group(); mesh.position.copy(origin); mesh.lookAt(origin.clone().add(direction));
            const ringGeo = new THREE.TorusGeometry(0.6, 0.1, 8, 16); ringGeo.rotateX(Math.PI/2); const ring = new THREE.Mesh(ringGeo, new THREE.MeshBasicMaterial({ color: 0xffd700, side: THREE.DoubleSide })); mesh.add(ring);
            const core = new THREE.Mesh(new THREE.SphereGeometry(0.3), new THREE.MeshBasicMaterial({ color: 0xffaa00, transparent: true, opacity: 0.8 })); mesh.add(core); scene.add(mesh);
            const stats = isPlayer ? player : enemy;
            skillshots.push({ mesh: mesh, dir: direction, speed: spells.w.speed, range: spells.w.range + (stats.range > 8 ? stats.range : 0), traveled: 0, damage: 0, isPlayer: isPlayer, radius: spells.w.width/2, type: 'W', emitParticles: false, level: level });
        }
        function spawnParticle(pos) { const geo = new THREE.PlaneGeometry(0.8, 0.8); const mat = new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.6, side: THREE.DoubleSide, blending: THREE.AdditiveBlending }); const p = new THREE.Mesh(geo, mat); p.position.copy(pos); p.lookAt(camera.position); p.rotation.z = Math.random() * Math.PI; scene.add(p); particles.push({ mesh: p, life: 1.0 }); }
        function applyCooldownReduction(stats) { const reduction = 1500; stats.cooldowns.q = Math.max(0, stats.cooldowns.q - reduction); stats.cooldowns.w = Math.max(0, stats.cooldowns.w - reduction); stats.cooldowns.d = Math.max(0, stats.cooldowns.d - reduction); stats.cooldowns.f = Math.max(0, stats.cooldowns.f - reduction); }
        function attachWMark3D(targetMesh, stats, level) { if (stats.wMark.mesh) { targetMesh.remove(stats.wMark.mesh); stats.wMark.mesh = null; } const markGroup = new THREE.Group(); const ringGeo = new THREE.TorusGeometry(0.8, 0.08, 16, 32); const ringMat = new THREE.MeshBasicMaterial({ color: 0xffd700, side: THREE.DoubleSide }); const ring = new THREE.Mesh(ringGeo, ringMat); ring.rotation.x = Math.PI / 2; markGroup.add(ring); const cylGeo = new THREE.CylinderGeometry(0.8, 0.8, 2.0, 32, 1, true); const cylMat = new THREE.MeshBasicMaterial({ color: 0xffaa00, transparent: true, opacity: 0.3, side: THREE.DoubleSide, blending: THREE.AdditiveBlending }); const cyl = new THREE.Mesh(cylGeo, cylMat); cyl.position.y = 1.0; markGroup.add(cyl); const glowGeo = new THREE.CircleGeometry(0.7, 32); const glowMat = new THREE.MeshBasicMaterial({ color: 0xffffaa, transparent: true, opacity: 0.4, side: THREE.DoubleSide, blending: THREE.AdditiveBlending }); const glow = new THREE.Mesh(glowGeo, glowMat); glow.rotation.x = -Math.PI / 2; markGroup.add(glow); markGroup.position.set(0, -1.05, 0); targetMesh.add(markGroup); stats.wMark.active = true; stats.wMark.time = Date.now(); stats.wMark.mesh = markGroup; stats.wMark.appliedLevel = level; }
        function popWMark(stats, ownerStats, attackerPos, targetMesh) { if(stats.wMark.active && Date.now() - stats.wMark.time < 4000) { stats.wMark.active = false; if (stats.wMark.mesh) { targetMesh.remove(stats.wMark.mesh); stats.wMark.mesh = null; } const burstDmg = getWDamage(stats.wMark.appliedLevel || 1, ownerStats); dealDamage(stats, burstDmg, stats === player); ownerStats.curMana = Math.min(ownerStats.maxMana, ownerStats.curMana + 60); const v = attackerPos.clone().add(new THREE.Vector3(0,2,0)); v.project(camera); showDamage("+60 Mana", (v.x*.5+.5)*innerWidth, (-(v.y*.5)+.5)*innerHeight - 30, true); } }
        function checkWMarkTimeout(stats, targetMesh) { if (stats.wMark.active && Date.now() - stats.wMark.time >= 4000) { stats.wMark.active = false; if (stats.wMark.mesh) { targetMesh.remove(stats.wMark.mesh); stats.wMark.mesh = null; } } }
        function tryCastD(caster, stats) { const chObj = (caster === pMesh) ? pChannel : eChannel; if (chObj.active) return; if (Date.now() - stats.cooldowns.d < getCooldown(spells.d.cd, stats.haste)) return; stats.cooldowns.d = Date.now(); stats.curHp += spells.d.heal; onAbilityUse(stats); if(stats.hasSonic) spawnSonicBoom(caster.position); createHealVisual(caster); updateUI(); }
        
        function tryCastF(caster, stats, targetPos) { 
            if (Date.now() - stats.cooldowns.f < getCooldown(spells.f.cd, stats.haste)) return; 
            const dir = new THREE.Vector3().subVectors(targetPos, caster.position).normalize(); dir.y = 0; const dest = caster.position.clone().add(dir.multiplyScalar(spells.f.dist)); 
            if(dest.length() < MAP_RADIUS - 1) { 
                stats.cooldowns.f = Date.now(); 
                if(stats.hasEarthwake) spawnEarthwake(caster.position, dest);
                if(stats.hasSonic) spawnSonicBoom(caster.position);
                createFlashVisual(caster.position); caster.position.copy(dest); caster.position.y = 1.5; if(caster === pMesh) targetPosition.copy(dest); 
            } updateUI(); 
        }

        function createFlashVisual(pos, color=0xffff00) { const m = new THREE.Mesh(new THREE.SphereGeometry(1), new THREE.MeshBasicMaterial({ color: color })); m.position.copy(pos); scene.add(m); setTimeout(() => scene.remove(m), 200); }
        function createHealVisual(caster) { const m = new THREE.Mesh(new THREE.CylinderGeometry(1, 1, 4, 16), new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.5 })); m.position.copy(caster.position); scene.add(m); const iv = setInterval(() => { m.position.y += 0.1; m.material.opacity -= 0.05; if(m.material.opacity<=0) { clearInterval(iv); scene.remove(m); }}, 50); }
        
        function spawnSonicBoom(pos) {
            const m = new THREE.Mesh(new THREE.SphereGeometry(4), new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.3 })); m.position.copy(pos); scene.add(m);
            setTimeout(()=>scene.remove(m), 300);
            [pMesh, eMesh].forEach(target => {
                if(target.position.distanceTo(pos) < 4 && target.position.distanceTo(pos) > 0.5) {
                   const s = (target===pMesh) ? player : enemy;
                   dealDamage(s, 50, s===player); 
                }
            });
        }
        function spawnEarthwake(start, end) {
            const m = new THREE.Mesh(new THREE.CylinderGeometry(1, 1, start.distanceTo(end), 8), new THREE.MeshBasicMaterial({ color: 0x555555 }));
            const mid = start.clone().lerp(end, 0.5); mid.y = 0.2;
            m.position.copy(mid); m.lookAt(end); m.rotateX(Math.PI/2);
            scene.add(m);
            setTimeout(() => {
                scene.remove(m);
                const s = (start.distanceTo(pMesh.position) < start.distanceTo(eMesh.position)) ? enemy : player;
                const mesh = (s===player) ? pMesh : eMesh;
                if(mesh.position.distanceTo(mid) < 5) dealDamage(s, 200, s===player);
            }, 1000);
        }

        function dealDamage(stats, amount, isPlayerTarget) {
            let finalDmg = amount;
            
            const attacker = isPlayerTarget ? enemy : player;
            if(attacker.critChance > 0 && Math.random() < attacker.critChance) {
                finalDmg *= attacker.critDmg;
            }

            finalDmg *= stats.defenseMult;
            if(attacker.augments.some(a=>a.id==='executioner') && stats.curHp < stats.maxHp*0.5) finalDmg *= 1.15;

            stats.curHp -= finalDmg;
            
            if (attacker.lifesteal > 0) {
                const heal = finalDmg * attacker.lifesteal;
                attacker.curHp = Math.min(attacker.maxHp, attacker.curHp + heal);
                const mesh = isPlayerTarget ? eMesh : pMesh;
                const v = mesh.position.clone().add(new THREE.Vector3(0,2,0)); v.project(camera);
                showDamage(`+${Math.floor(heal)}`, (v.x*.5+.5)*innerWidth + 20, (-(v.y*.5)+.5)*innerHeight - 20, false, true);
            }

            const obj = isPlayerTarget ? pMesh : eMesh; const vec = obj.position.clone(); vec.y += 2; vec.project(camera);
            showDamage(Math.floor(finalDmg), (vec.x*.5+.5)*innerWidth, (-(vec.y*.5)+.5)*innerHeight, false, false, finalDmg > amount * 1.4);
            updateUI(); checkDeath();
        }

        let targetPosition = new THREE.Vector3(0, 1.5, 0), lockedTarget = null; const raycaster = new THREE.Raycaster(), mouse = new THREE.Vector2(); let lastMouseE;
        window.addEventListener('mousemove', e => lastMouseE = e);
        function getMouse3D() { if(!lastMouseE) return null; mouse.x = (lastMouseE.clientX / innerWidth) * 2 - 1; mouse.y = -(lastMouseE.clientY / innerHeight) * 2 + 1; raycaster.setFromCamera(mouse, camera); const hits = raycaster.intersectObject(plane); return hits.length ? hits[0].point : null; }
        window.addEventListener('keydown', (e) => { if (e.key === 'Tab') { e.preventDefault(); updateScoreboardData(); ui.scoreboard.style.display = 'flex'; return; } if(isDead || pChannel.active || isSelecting || !gameStarted) return; const pt = getMouse3D(); if (!pt) return; if (e.key.toLowerCase() === 'q') tryCastQ(pMesh, player, pt); if (e.key.toLowerCase() === 'w') tryCastW(pMesh, player, pt); if (e.key.toLowerCase() === 'd') tryCastD(pMesh, player); if (e.key.toLowerCase() === 'f') tryCastF(pMesh, player, pt); });
        window.addEventListener('keyup', (e) => { if (e.key === 'Tab') ui.scoreboard.style.display = 'none'; });
        window.addEventListener('contextmenu', (e) => { e.preventDefault(); if(isDead || pChannel.active || isSelecting || !gameStarted) return; const pt = getMouse3D(); if(!pt) return; if(pt.distanceTo(eMesh.position) < 2 && eMesh.visible) { lockedTarget = eMesh; createClickMarker(eMesh.position.x, eMesh.position.z, 0xff0000); } else { lockedTarget = null; if(pt.length() > MAP_RADIUS - 1.5) pt.setLength(MAP_RADIUS - 1.5); targetPosition.set(pt.x, 1.5, pt.z); createClickMarker(pt.x, pt.z, 0x00ff00); } });
        function createClickMarker(x, z, c) { const m = new THREE.Mesh(new THREE.RingGeometry(0.5, 0.7, 16), new THREE.MeshBasicMaterial({ color: c, side: 2 })); m.rotation.x = -Math.PI/2; m.position.set(x, 0.1, z); scene.add(m); setTimeout(()=>scene.remove(m), 500); }

        function checkDeath() {
            if (player.curHp <= 0 && !isDead) {
                isDead = true; pMesh.visible = false; 
                enemy.kills++; player.deaths++; 
                if ((player.kills + enemy.kills) % 2 === 0) { gainLevel(player); gainLevel(player); gainLevel(enemy); gainLevel(enemy); }
                enemy.curHp = enemy.maxHp; enemy.curMana = enemy.maxMana; announce(false); ui.portrait.classList.add('dead-filter'); ui.deathTimer.style.display='flex';
                let t = 5; ui.deathTimer.innerText = t; const iv = setInterval(()=>{ t--; ui.deathTimer.innerText=t; if(t<=0){ clearInterval(iv); respawn(true); } }, 1000);
                setTimeout(() => { if (player.augments.length < AUGMENT_CAP) showAugmentSelection(); }, 2000);
            }
            if (enemy.curHp <= 0 && !isEnemyDead) {
                isEnemyDead = true; eMesh.visible = false; 
                player.kills++; player.cs++; enemy.deaths++; player.gold += 300; 
                if ((player.kills + enemy.kills) % 2 === 0) { gainLevel(player); gainLevel(player); gainLevel(enemy); gainLevel(enemy); }
                player.curHp = player.maxHp; player.curMana = player.maxMana; announce(true); 
                setTimeout(() => { if (player.augments.length < AUGMENT_CAP) showAugmentSelection(); respawn(false); }, 2000);
            }
        }
        
        function respawn(isP) { 
            const angle = Math.random() * Math.PI * 2;
            const radius = Math.random() * (MAP_RADIUS - 5);
            const x = Math.cos(angle) * radius;
            const z = Math.sin(angle) * radius;

            if(isP) { 
                isDead = false; pMesh.visible = true; 
                pMesh.position.set(x, 1.5, z); 
                targetPosition.set(x, 1.5, z); 
                player.curHp = player.maxHp; player.curMana = player.maxMana; 
                ui.portrait.classList.remove('dead-filter'); ui.deathTimer.style.display='none'; 
            } else { 
                isEnemyDead = false; eMesh.visible = true; 
                eMesh.position.set(x, 1.5, z); 
                enemyNav.set(x, 1.5, z);
                enemy.curHp = enemy.maxHp; enemy.curMana = enemy.maxMana; 
            } 
            updateUI(); 
        }

        let enemyNav = new THREE.Vector3(10, 1.5, 10);
        function updateAI(delta) { 
            if(isEnemyDead || eChannel.active || isSelecting || !gameStarted) return; 
            const dist = eMesh.position.distanceTo(pMesh.position); 
            let aiMoving = false; 
            if (enemy.curHp < enemy.maxHp * 0.3) tryCastD(eMesh, enemy); 
            let dodgeVector = null, criticalThreat = false; 
            
            for (let s of skillshots) { 
                if (s.isPlayer && s.mesh.visible) { 
                    const toProj = s.mesh.position.clone().sub(eMesh.position), distToProj = toProj.length();
                    const predictedPos = s.mesh.position.clone().add(s.dir.clone().multiplyScalar(distToProj)); 
                    if (predictedPos.distanceTo(eMesh.position) < s.radius + 2.0 && distToProj < 15) { 
                        const perp = new THREE.Vector3(-s.dir.z, 0, s.dir.x).normalize(); 
                        if (eMesh.position.clone().sub(s.mesh.position).dot(perp) < 0) perp.negate(); 
                        dodgeVector = perp; 
                        if (distToProj < 6 && s.type === 'Q') criticalThreat = true; 
                    } 
                } 
            } 
            
            if (criticalThreat && Date.now() - enemy.cooldowns.f > getCooldown(spells.f.cd, enemy.haste)) { 
                tryCastF(eMesh, enemy, eMesh.position.clone().add(dodgeVector.multiplyScalar(10))); return; 
            } else if (dodgeVector) { 
                const dodgeStep = dodgeVector.multiplyScalar(12.0 * delta * enemy.moveSpeedMod); 
                eMesh.position.add(dodgeStep); eMesh.lookAt(pMesh.position); updateAnimState(eAnim, true); return; 
            } 
            
            if (!isDead) { 
                const isExecute = (player.curHp / player.maxHp) <= 0.15; 
                if (dist <= spells.w.range && enemy.curMana > spells.w.mana + spells.q.mana && Date.now() - enemy.cooldowns.w > getCooldown(spells.w.cd, enemy.haste)) { tryCastW(eMesh, enemy, pMesh.position); return; } 
                if (dist <= spells.q.range && Date.now() - enemy.cooldowns.q > getCooldown(spells.q.cd, enemy.haste) && enemy.curMana >= spells.q.mana) { tryCastQ(eMesh, enemy, pMesh.position); return; } 
                if (dist <= enemy.range) { 
                    eMesh.lookAt(pMesh.position); 
                    if (Date.now() - enemy.lastAttack > enemy.attackSpeed) { spawnProj(eMesh, pMesh, 0xaa00ff); enemy.lastAttack = Date.now(); playLockedAnimation(eAnim, eAnim.actions.atk); } 
                } 
                let moveTarget = null; 
                if (isExecute) { 
                    if (dist > 3) moveTarget = pMesh.position.clone(); 
                } else { 
                    if (eMesh.position.distanceTo(enemyNav) < 2) { const angle = Math.random() * Math.PI * 2, r = Math.random() * (MAP_RADIUS - 2); enemyNav.set(Math.cos(angle) * r, 1.5, Math.sin(angle) * r); } 
                    moveTarget = enemyNav; 
                } 
                if (moveTarget) { 
                    const dir = new THREE.Vector3().subVectors(moveTarget, eMesh.position).normalize();
                    const nextPos = eMesh.position.clone().add(dir.multiplyScalar(7.2 * delta * enemy.moveSpeedMod)); 
                    if (nextPos.length() < MAP_RADIUS - 1) { eMesh.position.copy(nextPos); if (!isExecute || dist > 10) eMesh.lookAt(moveTarget); else eMesh.lookAt(pMesh.position); aiMoving = true; } 
                    else { enemyNav.set((Math.random()-0.5)*20, 1.5, (Math.random()-0.5)*20); } 
                } 
            } else { 
                if (eMesh.position.distanceTo(enemyNav) < 1) { enemyNav.set((Math.random()-0.5)*40, 1.5, (Math.random()-0.5)*40); if(enemyNav.length() > MAP_RADIUS-2) enemyNav.setLength(MAP_RADIUS-2); } 
                const d = new THREE.Vector3().subVectors(enemyNav, eMesh.position).normalize();
                const n = eMesh.position.clone().add(d.multiplyScalar(7.2 * delta * enemy.moveSpeedMod)); 
                eMesh.position.copy(n); eMesh.lookAt(enemyNav); aiMoving = true; 
            } 
            updateAnimState(eAnim, aiMoving); 
        }

        function spawnProj(owner, target, color) { 
            const mesh = new THREE.Group(); const core = new THREE.Mesh(new THREE.SphereGeometry(0.2), new THREE.MeshBasicMaterial({ color: 0xffffaa })); mesh.add(core); const glow = new THREE.Mesh(new THREE.SphereGeometry(0.35), new THREE.MeshBasicMaterial({ color: 0xffaa00, transparent: true, opacity: 0.6, blending: THREE.AdditiveBlending })); mesh.add(glow); const trail = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0, 1.5, 8), new THREE.MeshBasicMaterial({ color: 0xffaa00, transparent: true, opacity: 0.4 })); trail.rotation.x = -Math.PI/2; trail.position.z = -0.8; mesh.add(trail); mesh.position.copy(owner.position); mesh.position.y = 1.5; 
            const stats = (owner === pMesh) ? player : enemy;
            let dmg = stats.damage * stats.dmgMult;
            mesh.userData = { t: target, o: owner, spd: 55, dmg: dmg, type: 'primary' }; 
            scene.add(mesh); projectiles.push(mesh); 
            
            if(stats.hasTyphoon) {
                const bolt = mesh.clone();
                bolt.scale.set(0.7, 0.7, 0.7);
                bolt.userData = { t: target, o: owner, spd: 48, dmg: dmg * 0.5, type: 'secondary' };
                bolt.position.x += 0.5; 
                scene.add(bolt); projectiles.push(bolt);
            }
        }

        function enforceCaps(stats) {
            // Attack Speed Cap (2.5 attacks/sec = 400ms delay)
            if (!stats.hasTap) {
                if (stats.attackSpeed < 400) stats.attackSpeed = 400;
            } else {
                if (stats.attackSpeed < 50) stats.attackSpeed = 50; 
            }

            // Crit Cap
            if (stats.critChance > 1.0) stats.critChance = 1.0;

            // Defense Cap (Max 80% reduction)
            if (stats.defenseMult < 0.2) stats.defenseMult = 0.2;
            
            // Move Speed Cap (prevent zooming)
            if (stats.moveSpeedMod > 3.0) stats.moveSpeedMod = 3.0; 
        }

        let lastPos = new THREE.Vector3();
        function animate() {
            requestAnimationFrame(animate); 
            if(!gameStarted) return; 

            const delta = clock.getDelta(); 
            
            if (pAnim.mixer) pAnim.mixer.update(delta); if (eAnim.mixer) eAnim.mixer.update(delta);
            checkChannels(); checkWMarkTimeout(player, pMesh); checkWMarkTimeout(enemy, eMesh);
            if (player.wMark.mesh) player.wMark.mesh.rotation.y += delta * 3; if (enemy.wMark.mesh) enemy.wMark.mesh.rotation.y += delta * 3;

            if (pMesh.visible) {
                const pctX = (pMesh.position.x + MAP_RADIUS) / (MAP_RADIUS*2);
                const pctY = (pMesh.position.z + MAP_RADIUS) / (MAP_RADIUS*2);
                ui.mmPlayer.style.left = (pctX * 100) + '%'; ui.mmPlayer.style.top = (pctY * 100) + '%';
            }
            if (eMesh.visible && !isEnemyDead) {
                const pctX = (eMesh.position.x + MAP_RADIUS) / (MAP_RADIUS*2);
                const pctY = (eMesh.position.z + MAP_RADIUS) / (MAP_RADIUS*2);
                ui.mmEnemy.style.left = (pctX * 100) + '%'; ui.mmEnemy.style.top = (pctY * 100) + '%'; ui.mmEnemy.style.display = 'block';
            } else { ui.mmEnemy.style.display = 'none'; }

            [player, enemy].forEach(s => {
                const m = (s === player) ? pMesh : eMesh;
                if(s.hasRestless) {
                    const dist = m.position.distanceTo(lastPos); s.distanceMoved += dist;
                    if(s.distanceMoved > 10) { s.curHp = Math.min(s.maxHp, s.curHp + (s.maxHp * 0.02)); s.distanceMoved = 0; }
                }
                if(s.hasDawn) {
                    if(s.curHp / s.maxHp < 0.5 && Date.now() > s.dawnCd) {
                        const heal = s.maxHp * 0.30; s.curHp = Math.min(s.maxHp, s.curHp + heal); s.dawnCd = Date.now() + 15000; createHealVisual(m);
                    }
                }
                if(s.hasSymphony) { s.symStacks += delta; s.damage += delta * 0.5; s.attackSpeed *= 0.999; }
                
                // --- NEW: Enforce Caps Every Frame ---
                enforceCaps(s);
            });
            lastPos.copy(pMesh.position);

            if(!isDead && !pChannel.active && !isSelecting) {
                const regenAmount = (REGEN_PER_SEC * player.hpRegenMod) * delta; player.curHp = Math.min(player.maxHp, player.curHp + regenAmount); player.curMana = Math.min(player.maxMana, player.curMana + regenAmount);
                if(!isEnemyDead) { const eRegen = (REGEN_PER_SEC * enemy.hpRegenMod) * delta; enemy.curHp = Math.min(enemy.maxHp, enemy.curHp + eRegen); enemy.curMana = Math.min(enemy.maxMana, enemy.curMana + eRegen); }
                let playerMoving = false;
                
                const baseSpeed = 9.0;
                const speedMod = baseSpeed * player.moveSpeedMod + (player.hasTap ? 3.0 : 0);

                if(lockedTarget && lockedTarget.visible) {
                    if (pMesh.position.distanceTo(lockedTarget.position) <= player.range) {
                        pMesh.lookAt(lockedTarget.position);
                        if (Date.now() - player.lastAttack > player.attackSpeed) { spawnProj(pMesh, lockedTarget, 0xffff00); player.lastAttack = Date.now(); playLockedAnimation(pAnim, pAnim.actions.atk); }
                    } else { 
                        const d = new THREE.Vector3().subVectors(lockedTarget.position, pMesh.position).normalize();
                        const moveStep = d.multiplyScalar(speedMod * delta);
                        const nextPos = pMesh.position.clone().add(moveStep); 
                        playerMoving = true; pMesh.position.copy(nextPos); pMesh.lookAt(lockedTarget.position); targetPosition.copy(pMesh.position); 
                    }
                } else if (pMesh.position.distanceTo(targetPosition) > 0.1) { 
                    const d = new THREE.Vector3().subVectors(targetPosition, pMesh.position).normalize();
                    const moveStep = d.multiplyScalar(speedMod * delta);
                    const nextPos = pMesh.position.clone().add(moveStep); 
                    playerMoving = true; pMesh.position.copy(nextPos); pMesh.lookAt(targetPosition); 
                }
                updateAnimState(pAnim, playerMoving);
            }
            updateAI(delta);

            for(let i=particles.length-1; i>=0; i--) { const p = particles[i]; p.life -= delta * 2.0; p.mesh.material.opacity = p.life * 0.6; p.mesh.scale.multiplyScalar(0.95); if(p.life <= 0) { scene.remove(p.mesh); particles.splice(i, 1); } }
            
            for (let i=projectiles.length-1; i>=0; i--) { 
                const p = projectiles[i]; 
                if(!p.userData.t.visible || (p.userData.t === pMesh && isDead)) { scene.remove(p); projectiles.splice(i,1); continue; } 
                const dir = new THREE.Vector3().subVectors(p.userData.t.position, p.position).normalize(); 
                p.position.add(dir.multiplyScalar(p.userData.spd * delta)); 
                p.lookAt(p.userData.t.position); 
                if (p.position.distanceTo(p.userData.t.position) < 1) { 
                    scene.remove(p); projectiles.splice(i,1); 
                    const stats = (p.userData.o === pMesh) ? player : enemy;
                    let dmg = p.userData.dmg;
                    if(stats.hasHeavy) dmg += stats.maxHp * 0.05;
                    if(stats.hasTwice) {
                        stats.attackCount++;
                        if(stats.attackCount % 3 === 0) dmg *= 2; 
                    }
                    if(stats.hasMystic || stats.hasInfernal) { stats.cooldowns.q -= 1000; stats.cooldowns.w -= 1000; stats.cooldowns.d -= 1000; stats.cooldowns.f -= 1000; }
                    
                    const isEnemy = p.userData.t === eMesh;
                    dealDamage(isEnemy ? enemy : player, dmg, !isEnemy);
                    
                    if(stats.hasBurn) {
                         let ticks = 3; 
                         const burnIv = setInterval(() => { 
                             if(ticks<=0 || (isEnemy && isEnemyDead) || (!isEnemy && isDead)) clearInterval(burnIv);
                             else dealDamage(isEnemy ? enemy : player, 10, !isEnemy);
                             ticks--;
                         }, 500);
                    }

                    if (isEnemy) popWMark(enemy, player, pMesh.position, eMesh); 
                    else popWMark(player, enemy, eMesh.position, pMesh); 
                } 
            }

            for (let i = skillshots.length - 1; i >= 0; i--) { 
                const s = skillshots[i]; 
                const moveDist = s.speed * delta;
                s.mesh.position.add(s.dir.clone().multiplyScalar(moveDist)); 
                s.traveled += moveDist; 
                if(s.type === 'W') s.mesh.children[0].rotation.z += 0.2; 
                if(s.emitParticles) spawnParticle(s.mesh.position.clone()); 
                let hit = false; 
                const potentialTarget = s.isPlayer ? eMesh : pMesh, stats = s.isPlayer ? enemy : player, ownerStats = s.isPlayer ? player : enemy; 
                if (potentialTarget.visible && s.mesh.position.distanceTo(potentialTarget.position) < s.radius + 1.5 * stats.scale) { 
                    hit = true; 
                    if (s.type === 'Q') { dealDamage(stats, s.damage, !s.isPlayer); if(s.isPlayer) applyCooldownReduction(player); popWMark(stats, ownerStats, s.mesh.position, potentialTarget); } 
                    else if (s.type === 'W') { attachWMark3D(potentialTarget, stats, s.level || 1); } 
                } 
                if (hit || s.traveled >= s.range) { scene.remove(s.mesh); skillshots.splice(i, 1); } 
            }

            if(pMesh.visible) { const v = pMesh.position.clone().add(new THREE.Vector3(0,2.4 * player.scale,0)); v.project(camera); ui.pOverhead.style.left = (v.x*.5+.5)*innerWidth+'px'; ui.pOverhead.style.top = (-(v.y*.5)+.5)*innerHeight+'px'; } else ui.pOverhead.style.display = 'none';
            if(eMesh.visible) { const v = eMesh.position.clone().add(new THREE.Vector3(0,3.5 * enemy.scale,0)); v.project(camera); ui.eOverhead.style.left = (v.x*.5+.5)*innerWidth+'px'; ui.eOverhead.style.top = (-(v.y*.5)+.5)*innerHeight+'px'; ui.eOverhead.style.display = 'flex'; } else ui.eOverhead.style.display = 'none';
            updateUI();
            camera.position.x = pMesh.position.x * 0.5; camera.position.z = pMesh.position.z * 0.5 + 35; camera.lookAt(pMesh.position);
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => { camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth, innerHeight); });
        animate();
    </script>
</body>
</html>
<!-- END OF FILE update_caps_no_demon.html -->